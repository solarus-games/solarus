/**
\page lua_api_timer Timers

Timers allow you to call a function in the future with a specified delay.

Here is a first example of use:

\verbatim
-- Play sound "secret" in one second.
function play_secret_sound()
  sol.audio.play_sound("secret")
end

sol.timer.start(1000, play_secret_sound)
\endverbatim

Shorter version to do the same thing:

\verbatim
-- Equivalent code using an anonymous function.
sol.timer.start(1000, function()
  sol.audio.play_sound("secret")
end)
\endverbatim

\section Contents

- \ref lua_api_timer_functions
- \ref lua_api_timer_methods

<hr>

\section lua_api_timer_functions Functions of sol.timer

<hr>

\subsection lua_api_timer_start sol.timer.start([context], delay, callback)

Sets a function to be called after a delay.

If the delay is set to zero, the function is called immediately.
- \c context (map, enemy, game, item, menu or \c sol.main; optional): Determines the lifetime of
  the timer.
  The context is where the timer belongs.<br>
  If the context gets closed before the timer is finished, then
  the timer is automatically canceled.
  More precisely, the following rules are applied.
  - If you set the context to a \ref lua_api_map "map", the timer is canceled
    when the player goes to another map.<br>
    Example: a button that opens a door for a limited time.
  - If you set the context to a \ref lua_api_game "game"
    or an \ref lua_api_item "item",
    the timer is canceled when the game is closed.
    (Items have the same lifetime as the game they belong to.)
    This is only possible when the game is running.
    Example: hot water that becomes cold after a few minutes,
    and that the player should bring to an %NPC on another map while it's still
    hot.
  - If you set the context to an \ref lua_api_enemy "enemy", the timer is
    canceled when the enemy is killed or removed from the map.
    Most enemy scripts usually create timers.
    Example: a boss who shoots fireballs every 10 seconds.
  - If you set the context to a \ref lua_api_menu "menu", the timer is
    canceled when the menu is closed.
    Example: in the title screen, show some game sequences after a few seconds
    without action from the user.
  - If you set the context to the \ref lua_api_main "sol.main" table, the
    timer is canceled when Lua is closed. Thus, it will be a global timer.
    This kind of timer is not often needed.
    Example: dumping some global information periodically while the program is
    running.
  - If you don't specify a context, then a default context is set for you:
    the current map during a game, and \c sol.main if no game is running.
- \c delay (number): Delay before calling the function in milliseconds.
- \c callback (function): The function to be called when the timer finishes.
- Return value (timer): The timer created (or \c nil if \c delay is \c 0).
  Most of the time, you don't need to store the returned timer.
  Indeed, there is no problem if it gets garbage-collected: the timer persists
  in the engine side until its completion or the end of its context.
  Usually, you will store the return value only if you need to stop the timer
  explicitly later or to call another method on it.

<hr>

\subsection lua_api_timer_stop_all sol.timer.stop_all(context)

Cancels all timers that are currently running in a context.
- \c context (map, enemy, game, item, menu or \c sol.main): The context where you
  want to stop timers.

This function is equivalent to calling \ref lua_api_timer_stop on each timer
of the context.
It may allows you to avoid to store explicitly all your timers.

Keep in mind that timers are already automatically stopped when their context
finishes: when the player goes to another map, map timers are canceled,
when an enemy is killed, its timers are canceled, etc.

But the end of a context is not the only reason why you may want its timers
to be canceled.
Typically, when an enemy is hurt, you may want to cancel all its timers, because
you don't want your enemy to perform its next attacks or to make a
movement during its hurting animation.

<hr>

\section lua_api_timer_methods Methods of the type timer

<hr>

\subsection lua_api_timer_stop timer:stop()

Cancels this timer.

If the timer was already finished or canceled, nothing happens.

<hr>

\subsection lua_api_timer_is_with_sound timer:is_with_sound()

Returns whether a clock sound is played repeatedly during this timer.
- Return value (boolean): \c true if a clock sound is played with this timer.

<hr>

\subsection lua_api_timer_set_with_sound timer:set_with_sound(with_sound)

Sets whether a clock sound is played repeatedly during this timer.
- \c with_sound (boolean, optional): \c true to play a clock sound
  repeatedly (no value means \c true).

<hr>

\subsection lua_api_timer_is_suspended timer:is_suspended()

Returns whether this timer is currently suspended.
- Return value (boolean): \c true if this timer is currently suspended.

<hr>

\subsection lua_api_timer_set_suspended timer:set_suspended([suspended])

Returns whether this timer is currently suspended.
- \c suspended (boolean, optional): \c true to suspend the timer, \c false to
  unsuspended it (no value means \c true).

<hr>

\subsection lua_api_timer_is_suspended_with_map timer:is_suspended_with_map()

Returns whether this timer gets automatically suspended when the map is
suspended.
- Return value (boolean): \c true if this timer is currently suspended.

<hr>

\subsection lua_api_timer_set_suspended_with_map timer:set_suspended_with_map([suspended_with_map])

Sets whether this timer should automatically be suspended when the map gets
suspended.

The map is suspended by the engine in a few cases, like when the game is
paused or when the camera is being moved by a script.
When it happens, all map entities stop moving and most sprites stop their
animation.
With this setting, you can choose whether your timer gets suspended too.

By default, map timers, enemy timers and item timers are suspended with the
map.
- \c suspended_with_map (boolean, optional): \c true to suspend the timer when
  the map is suspended, \c false to continue (no value means \c true).

*/

